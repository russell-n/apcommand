HTTP Connection
===============
.. currentmodule:: apcommand.connections.httpconnection
This is a client-connection to communicate with HTTP-servers. Since some of the parameters are reminiscent of telnet and SSH sessions I will model it somewhat after the SSHConnection, but it will primarily act as an interface to the `requests <http://docs.python-requests.org/en/latest/>`_ package.

Example Get
-----------

An example use based on the Broadcom BCM94718NR::

    connection = HTTPConnection('192.168.1.1', password='admin', path='radio.asp')
    response = connection(data={'wl_unit':'0'})
    print response.text

The previous snippet would have printed the html page associated with the 2.4 GHz radio. The settings were based on :ref:`Aren's Broadcom Code <arens-broadcom>` which translates to curl's::

   curl -d 'wl_unit=0' --user :admin http://192.168.1.1/radio.asp

Setting parts of the URL in the HTTPConnection will re-build the URL so you could get the `ssid` page instead of the `radio` page like this::

    # re-using the previous connection
    connection.path = 'ssid.asp'
    response = connection.get(data={'wl_unit':'0'})
    print response.text

The use of `connection.get` is not a typo, the call is just a 'GET' call, since I figured it is the most common thing to do. The `repsonse` returned is a `requests.Response <http://docs.python-requests.org/en/latest/user/quickstart/#response-content>`_ object so the HTTPConnection doesn't act exactly like the other connections (which return standard-out and standard error in a tuple). There's more information here so I figured it would be better to return the whole thing rather than throw away stuff.

Persistence of Data
-------------------

Since I tested this a lot using `ipython` I made it so that it will store the `data` attribute and add it automatically when a request is made::

    connection = HTTPConnection('192.168.1.1', password='admin', path='radio.asp', data={'wl_unit':'0'})
    response = connection()
    print response.text

Should work the same as the first example. If you want to temporarily use a different data-set, pass in the dictionary (using the parameter name explicitly)::

    response = connection(data={'wl_unit':'1'})

If you want to get rid of the data set it to None, if you want to change it just assign it a new value::

    # no default data
    connection.data = None

    # new default data
    connection.data = {'wl_unit':'1'}

In this initial use I don't use parameters so I didn't do the same thing for them or any other settings that can be passed in --

   * The URL and authentication are always taken from the HTTPConnection properties

   * The data will be taken from the HTTPConnection properties if set or from the arguments if passed in

   * Everything else needs to be passed in when the connection is called
    
.. uml::

   HTTPConnection o- requests.Request
   HTTPConnection : GET(*args, **kwargs)

.. autosummary::
   :toctree: api

   HTTPConnection

The URL is being put together with the python `urlparse.urlunparse <http://docs.python.org/2/library/urlparse.html>`_ method. For future reference, the tuple that is passed to it has these fields:

.. csv-table:: ParseResult tuple
   :header: Name, Index, Description, Default
   
   scheme, 0, URL scheme specifier, empty string
   netloc, 1, Network location part, empty string
   path, 2, Hierarchical path, empty string
   params, 3, Parameters for last path element, empty string
   query, 4, Query component, empty string
   fragment, 5, Fragment identifier, empty string

<<name='imports', echo=False>>=
# python standard library
import urlparse
import threading

# this package
from apcommand.baseclass import BaseClass

# third-party
import requests
@
<<name='constants', echo=False>>=
PROTOCOL = 'http'
GET = 'GET'
EMPTY_STRING = ''
@
<<name="HTTPConnection", echo=False>>=
class HTTPConnection(BaseClass):
    """
    Acts as a client connection to an HTTP server
    """
    def __init__(self, hostname, username=EMPTY_STRING, password=EMPTY_STRING,
                 path=EMPTY_STRING, data=None, protocol=PROTOCOL,
                 lock=None):
        """
        HTTPConnection constructor

        :param:

         - `hostname`: Address or resolvable host-name (e.g. www.google.com)
         - `username`: Username for sites that need authentication
         - `password`: password for sites needing authentication
         - `path`: optional path to add to URL
         - `protocol`: transport protocol (most likely 'http')
         - `data`: dictionary of data for the page
         - `lock`: A re-entrant lock for users of the connection to share
        """
        self._hostname = None
        self.hostname = hostname
        self.username = username
        self.password = password
        self._protocol = None
        self.protocol = protocol
        self._path = None
        self.path = path
        self.data = data
        self._url = None
        self._lock = lock
        return

    @property
    def lock(self):
        """
        A re-entrant lock for clients to share

        :rtype: RLock
        """
        if self._lock is None:
            self._lock = threading.RLock()
        return

    @property
    def protocol(self):
        """
        The protocol for the URL (probabl http, maybe ftp)
        """
        return self._protocol

    @protocol.setter
    def protocol(self, new_protocol):
        """
        Sets the protocol, resets the url
        """
        self._protocol = new_protocol.lower()
        self._url = None
        return

    @property
    def hostname(self):
        """
        The address for the HTTP server
        """
        return self._hostname

    @hostname.setter
    def hostname(self, new_hostname):
        """
        Sets the hostname and resets the URL
        """
        self._hostname = new_hostname
        self._url = None
        return

    @property
    def path(self):
        """
        A path-string for the URL
        """
        return self._path

    @path.setter
    def path(self, new_path):
        """
        Sets the path and re-sets the url
        """
        self._path = new_path
        self._url = None
        return

    @property
    def url(self):
        """
        The URL for the server
        """
        if self._url is None:
            self._url = urlparse.urlunparse((self.protocol, self.hostname,
                                             self.path, EMPTY_STRING,
                                             EMPTY_STRING, EMPTY_STRING))
                                             
        return self._url

    def request(self, method, *args, **kwargs):
        """
        Calls requests.request(method, *args, **kwargs)

        :return: requests.Response object
        """
        if 'data' not in kwargs and self.data is not None:
            return requests.request(method, self.url, data=self.data,
                             auth=(self.username, self.password), *args, **kwargs)
        return requests.request(method, self.url,
                                auth=(self.username, self.password), *args, **kwargs)

    def __call__(self, *args, **kwargs):
        """
        A shortcut for GET requests

        :return: requests.Response object
        """
        return self.request(GET, *args, **kwargs)

    
    def __getattr__(self, method):
        """
        The parameters are the same as `requests.request` (method is converted to uppercase)
        
        :param:

         - `method`: The HTTP Method (GET, POST, HEAD, PATCH, DELETE)

        :return: requests.request method called with passed-in args and kwargs
        """
        def request_call(*args, **kwargs):
            return self.request(method.upper(), *args, **kwargs)
        return request_call
    
@
<<name='test_imports', echo=False>>=
# python standard library
import unittest
from random import randrange
import random
choose = random.choice
import string

# third-party
from mock import MagicMock, patch
@
<<name='TestHTTPConnection', echo=False>>=
random_letters = lambda : ''.join([choose(string.letters) for choice in xrange(randrange(100))])
class TestHTTPConnection(unittest.TestCase):
    def setUp(self):
        self.hostname = '192.168.1.1'
        self.username = random_letters()
        self.password = random_letters()
        self.auth = (self.username, self.password)
        self.data = {"wl_unit":'0'}
        self.path = 'radio.asp'
        self.url = 'http://' + self.hostname + '/' + self.path
        self.connection = HTTPConnection(hostname=self.hostname,
                                         username=self.username,
                                         password=self.password,
                                         data=self.data,
                                         path=self.path)

        # mocks
        self.requests = MagicMock()
        self.response = MagicMock()
        self.requests.return_value = self.response
        return

    def test_constructor(self):
        """
        Does the constructor match the signature?
        """
        self.assertEqual(self.hostname, self.connection.hostname)
        self.assertEqual(self.path, self.connection.path)
        self.assertEqual(self.username, self.connection.username)
        self.assertEqual(self.password, self.connection.password)
        
        self.assertEqual(self.url,
                         self.connection.url)
        self.assertEqual(self.data,
                         self.connection.data)
        return

    def test_request(self):
        """
        Does it call requests.request with the right signature?
        """
        with patch('requests.request', self.requests):
            # get
            outcome = self.connection.get()
            self.assertIsNotNone(self.connection.data)
            self.requests.assert_called_with('GET', self.connection.url,
                                                  auth=self.auth,
                                                  data=self.data)
            self.assertEqual(outcome, self.response)
            # post
            params = {'xor':'1', 'aor':'0'}
            self.connection.data = None
            outcome = self.connection.post(params=params)
            self.requests.assert_called_with('POST', self.connection.url,
                                             auth=self.auth,
                                             params=params)
            self.assertEqual(outcome, self.response)
        return

    def test_call(self):
        """
        Does the calling the HTTPConnection do the same thing as GET?
        """
        with patch('requests.request', self.requests):
            data = {'wl_radio':'1'}
            outcome = self.connection(data=data)
            self.requests.assert_called_with(GET, self.url, auth=self.auth,
                                             data=data)
        return

    def test_set_parameter(self):
        """
        Does setting parameters that affect the url reset it?
        """
        new_path = random_letters()
        self.assertEqual(self.url, self.connection.url)
        self.connection.path = new_path
        new_url = self.url.replace(self.path, new_path)
        self.assertEqual(new_url,
                         self.connection.url)
        new_hostname = random_letters()

        self.connection.hostname = new_hostname
        new_url = new_url.replace(self.hostname, new_hostname)
        self.assertEqual(new_url, self.connection.url)

        new_protocol = random_letters()
        new_url = new_url.replace(PROTOCOL, new_protocol.lower())
        self.connection.protocol = new_protocol
        self.assertEqual(new_url,
                         self.connection.url)
        return

@

<%
for case in (TestHTTPConnection,):
    suite = unittest.TestLoader().loadTestsFromTestCase(case)    
    unittest.TextTestRunner(verbosity=2).run(suite)
%>
