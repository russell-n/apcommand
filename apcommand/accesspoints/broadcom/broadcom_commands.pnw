The Broadcom Commands
=====================

.. currentmodule: apcommand.accesspoints.broadcom.broadcom_commands

Contents:

   * :ref:`Introduction <broadcom-commands-introduction>`
   * :ref:`BroadcomBaseData <broadcom-base-data>`

   * :ref:`BroadcomBaseCommand <broadcom-base-command>`

<<name='imports', echo=False>>=
# python standard library
from abc import ABCMeta, abstractproperty, abstractmethod
# this package
from apcommand.baseclass import BaseClass

# this package
from commons import action_dict
from commons import BroadcomWirelessData
from querier import Broadcom5GHzQuerier, Broadcom24GHzQuerier
@
.. _broadcom-commands-introduction:
Introduction
------------

I have decided to break the commands sent to the Broadcom into atomic actions. If they are run separately this will actually make them inefficient time-wise, as you need to put about a half-second pause between each call to the server or it will occasionally not respond, but my guess is that I will not have access to the Broadcom again for a long while and like most things here this will turn into a code-maintenance nightmare. To ameliorate the knowledge-gain, knowledge-lost cycle  I am trying to make the code as simple as possible at the possible expense of execution efficiency. Of course, one could argue that an explosion of classes does not simplify anything but I am hopeful that once the pattern of implementation is recognized only the relevant classes need be found and examined and so smaller will be better.

To allow for the aggregation of commands each command class has an `add` method which will allow other commands to be added to their data-dictionary. This way the `Apply` action only needs to be called once per page. There are too many things on the pages for me to check if they make sense, though, so user-beware.

A hypothetical example::

   connection = HTTPConnection('192.168.1.1', password='admin', path='radio.asp')
   set_channel = Set24GHzChannel(connection)
   disable = Disable5GHz(connection)
   set_channel += disable
   set_channel('11')

This should have the equivalent effect of::

    set_channnel('11')
    disable()

But since the first case only accesses the server once it should be faster. Also, if for some reason you want to remove the ``disable`` data from the ``set_channel`` data you can use::

    set_channel -= disable

In this case it would probably be better to re-create the ``set_channel``, but conceivably you could chain together many commands and there might be a reason to remove just one part of it.

.. _broadcom-base-data:
The Base Data
-------------

A *command* is data sent to the server. At a minimum the server is sent the interface information as data so that the :ref:`Soup <broadcom-radio-soup>` can find values in the html. The Base Data classes hold the Wireless Interface data for the specific bands. I was going to create it as a real class so it could be re-used but I think it makes more sense for the commands to use it once and throw it away so it is created with classmethods so that the actual object does not have to be created (although it can be if needed). I still have not quite worked out the logic of how this all fits together.

.. uml::

   BroadcomBaseData -|> BaseClass

.. autosummary::
   :toctree: api

   BroadcomBaseData
   BroadcomBaseData.base_data
   BroadcomBaseData.base_24_ghz_data
   BroadcomBaseData.base_5_ghz_data


<<name='BroadcomBaseData', echo=False>>=
class BroadcomBaseData(object):
    """
    The base-data to hold the data-dict
    """
    def __init__(self):
        """
        Base Data constructor
        """
        super(BroadcomBaseData, self).__init__()
        return

    @classmethod
    def base_data(cls):
        """
        Returns data dictionary that only has action:Apply 
        """
        return action_dict()

    @classmethod
    def base_24_ghz_data(cls):
        """
        data-dictionary to choose the 2.4 GHz interface
        """
        bwd = BroadcomWirelessData
        base_24_ghz_data = {bwd.wireless_interface: bwd.interface_24_ghz}
        return base_24_ghz_data

    @classmethod
    def base_5_ghz_data(cls):
        """
        data-dictionary to chose the 5 Ghz interface
        """
        bwd = BroadcomWirelessData
        base_5_ghz_data = {bwd.wireless_interface:bwd.interface_5_ghz}
        return base_5_ghz_data

    @classmethod
    def __call__(cls, action=True, band=None):
        """
        Builds a data-dict based on action and band

        :param:

         - `action`: if True, add action:Apply to the dict
         - `band`: if 2.4 or 5 add the interface selection data

        :return: base data-dict
        """
        band = str(band)
        if action:
            base_data = cls.base_data()
        else:
            base_data = {}

        if band.startswith('2'):
            base_data.update(cls.base_24_ghz_data())
        elif band.startswith('5'):
            base_data.update(cls.base_5_ghz_data())
        return

    def __repr__(self):
        """
        Returns a representation of the data
        """
        return "{0}: Base: {1} 5GHz: {1} 2.4GHz: {2}".format(self.__class__.__name__,
                                                             self.base_data(),
                                                             self.base_5_ghz_data(),
                                                             self.base_24_ghz_data())
@

.. _broadcom-base-command:
The Broadcom Base Command
-------------------------

As mentioned above, a `command` is a bundle of data to send to the web-server and the connection to send it over. The assumption is that there will be 6 cases to build the BaseCommand -- cases where no data is sent, cases where an interface has to be chosen but no action, cases with an interface and an action, and cases with an action but no interface. An action has to be sent if something is being changed, but should not be sent just to read the html. An interface needs to be chosen for pages dealing with wireless, but not for some of the pages not specific to wireless (e.g. the `LAN` page).

The data-dictionaries that need to be built will then meet the following cases (0 mean does not have this data, 1 mean has this data):

.. csv-table:: Base Data Dictionaries
   :header: Action,2.4 GHz,5 GHz

   0,0,0
   0,0,1
   0,1,0
   1,0,0
   1,0,1
   1,1,0

There are six rather than eight cases because you can only choose one Interface from the drop-down menu, not both.   

.. uml::

   BroadcomBaseCommand -|> BaseClass
   BroadcomBaseCommand o- HTTPConnection

.. autosummary::
   :toctree: api

   BroadcomBaseCommand
   BroadcomBaseData.base_data
   BroadcomBaseData.singular_data
   BroadcomBaseData.added_data
   BroadcomBaseData.non_base_data
   BroadcomBaseData.data
   BroadcomBaseData.__add__
   BroadcomBaseData.__sub__

This is getting a little convoluted so I will try and explain the data-dictionaries:

   * ``base_data``: this is set based on the band and action parameters and never changes
   * ``singular_data``: This is data added for a specific command to change settings
   * ``added_data``: this will be changed by the add and subtract operators
   * ``non_base_data``: this is ``singular_data`` updated by ``added_data``
   * ``data``: this is ``base_data`` updated by ``non_base_data``

The reason for all these data-dictionaries is so that commands can be composed from other commands. ``base_data`` and ``singular_data`` are part of the command-definition and so never change. ``non_base_data`` and ``data`` are generated every time ``added_data`` is changed (using the operators, if the ``added_data`` is changed directly then ``data`` and ``non_base_data`` will need to be reset). Only ``added_data`` is intended to change, and it is only changed using the other command's ``non_base_data`` so it will not change the original's Wireless Interface.

<<name='BroadcomBaseCommand', echo=False>>=
class BroadcomBaseCommand(BaseClass):
    """
    A base-class for the commands that change settings
    """
    __metaclass__ = ABCMeta
    def __init__(self, connection, band=None):
        """
        BroadcomBaseCommand constructor

        :param:

         - `connection`: A connection to the AP (HTTPConnection)
         - `band`: 2.4, 5, or None (chooses the data-dictionary)
        """
        self.connection = connection
        self._base_data = None
        self._singular_data = None
        self._added_data = None
        self._non_base_data = None
        self._data = None
        return

    @property
    def base_data(self):
        """
        A data-dictionary to add commands to
        """
        if self._base_data is None:
            self._base_data = BroadcomBaseData(action=True,
                                               band=self.band)
        return self._base_data

    @abstractproperty
    def singular_data(self):
        """
        A data dictionary with the command-specific data (or empty if querying)
        """
        if self._singular_data is None:
            self._singular_data = {}
        return self._singular_data    

    @property
    def added_data(self):
        """
        Maintains data added from other commands
        """
        if self._added_data is None:
            self._added_data = {}
        return self._added_data

    @property
    def non_base_data(self):
        """
        The singular data updated with any added data
        """
        if self._non_base_data is None:
            self._non_base_data = self.singular_data.copy()
            self._non_base_data.update(self.added_data)
        return self._non_base_data

    @property
    def data(self):
        """
        The data dictionary to send to the server
        """
        if self._data is None:
            self._data = self.base_data.copy()
            self._data.update(self.non_base_data)
        return self._data

    def __add__(self, other):
        """
        Adds the other's non_base_data to this added_data

        """
        self.added_data.update(other.non_base_data)
        self._data = self._non_base_data = None
        return

    def __sub__(self, other):
        """
        Removes the other's non-base data from added_data
        """
        for key in other.non_base_data.iterkeys():
            if key in self.added_data:
                del self.added_data[key]
        self._data = self._non_base_data = None
        return

    @abstractmethod
    def __call__(self):
        """
        The main method to change settings (probably needs arguments)
        """
        return
@
<<name='test_imports', echo=False>>=
# python standard library
import unittest

# third-party
from mock import MagicMock
@
<<name='TestBroadcomCommands', echo=False>>=
class BadChild(BroadcomBaseCommand):
    def query(self):
        return

class BadChild2(BroadcomBaseCommand):
    def base_data(self):
        return

class EvilChild(BroadcomBaseCommand):
    def base_data(self):
        return
    def query(self):
        return

    @property
    def singular_data(self):
        return
    
    def __call__(self):
        return
    
class TestBroadcomCommands(unittest.TestCase):
    def setUp(self):
        self.connection = MagicMock()
        return

    def test_abstract_property(self):
        """
        Does a class without the properties defined crash on creation?
        """
        self.assertRaises(TypeError, BroadcomBaseCommand, args=(self.connection,))
        self.assertRaises(TypeError, BadChild, args=(self.connection,))
        self.assertRaises(TypeError, BadChild2, args=(self.connection,))
        EvilChild(self.connection)
        return

    #def test_base_commands(self):
    #    """
    #    Do the band-specific base-commands build the right data and queries?
    #    """
    #    base_5 = Base5GHzCommand(connection=self.connection)
    #    data_dict = action_dict()
    #    data_dict['wl_unit'] = '1'
    #    self.assertEqual(data_dict, base_5.base_data)
    #
    #    base_24 = Base24GHzCommand(connection=self.connection)
    #    data_dict['wl_unit'] = '0'
    #    self.assertEqual(data_dict, base_24.base_data)
    #    return

    def test_add(self):
        return
@
<%
for case in (TestBroadcomCommands,):
    suite = unittest.TestLoader().loadTestsFromTestCase(case)    
    unittest.TextTestRunner(verbosity=2).run(suite)
%>

