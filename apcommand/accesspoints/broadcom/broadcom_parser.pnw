The Broadcom BCM94718NR Parser
==============================
.. currentmodule:: apcommand.accesspoints.broadcom.broadcom_parser
This is a module to hold an interpreter to pull information from the Broadcom html pages. It uses `BeautifulSoup <http://www.crummy.com/software/BeautifulSoup/>`_ to break the html tree apart and then regular expressions to extract the specific bits of text.

The `radio.asp` HTML
--------------------

I know very little about HTML and web scraping and am making this empirically so I will use this document as a lab-report as much as a code-module.

Radio State
~~~~~~~~~~~

Assuming that there is a `response` object that was returned from a 'GET' request to the `radio.asp` page, the 
state of the radio can be pulled using beautiful soup::

    soup = BeautifulSoup(response.text)
    state = soup.find(attrs={'name':'wl_radio'})

The `state` variable now should have some text like this::

    <select name="wl_radio">
    <option selected value="0">Disabled</option>
    <option value="1">Enabled</option>
    </select>

    
If you look at the `soup.find_all` parameters you can see that it chose the sub-tree that had a tag attribute matching the dictionary I passed in (there is also a `find_all` method that will return a list of all matching sub-trees, but in this case I know there is only one). 

The lines with the `option` tags can be interpreted this way:

    * if it has ``selected`` then that is the current Wireless Interface that the user would see if this were in a browser (when the GET request was made ``data={'wl_unit':'0'}`` was passed in as a parameter or it is the default) 

    * ``value='0'`` means the 2.4 GHz wireless interface, ``value='1'`` means the 5 GHz interface

    * If the text is 'Disabled', the radio is off, if 'Enabled' the radio is on

.. warning:: Although it looks like a string when you print the output of `soup.find` what you actually get is a `bs4.element.Tag` object.

The previous warning means that you can search it directly with a regular expression or string search, but you can cast it to a string::

    state_string = str(state)

It also means that you can use it to burrow your way down to the right child without regular expressions::

    select = soup.find(attrs={'name':'wl_radio'})
    band_24 = select.find(attrs={'value':'0'})
    state_string = band_24.text

The variable `state_string` now contains the (unicode) string 'Disabled'. You could also do it as one line::

    state_string = soup.find(attrs={'name':'wl_radio'}).find(attrs={'value':'0'}).text

The question now -- *is this a better solution than using regular expressions?* From a personal standpoint I would say no, regular expressions are more generalizabel, while this is a specific package. Then again, it would be impossible to decompose the html tree with just regular expressions (okay, hard, not impossible), so why would it be worse to use it to get the rest?

The answer for now will be to use BeautifulSoup function calls instead of regular expressions, until a case arises where they are needed.

.. note:: So, it appears that the Broadcom web interface adds a selected="" tag to drop-down options that are currently selected. You can get the surrounding tags but BeautifulSoup seems to not be able to find the `selected` tag. I have not figured out why, but this may be where switching to string searches and regular expressions would make sense.

.. _broadcom-parser-wireless-interface:
The Wireless Interface
~~~~~~~~~~~~~~~~~~~~~~

This is the drop-down that selects the current interface shown to the user (and which is configured if you are pushing changes).

The output of ``soup.find(attrs={'name':'wl_unit'})``:

<<name='wl_unit', echo=False>>=
wl_unit = """<select name="wl_unit" onchange="submit();">
<option selected value="0">(00:90:4C:09:11:03)</option>
<option value="1">(00:90:4C:13:11:03)</option>
</select>"""
print wl_unit
@

The SoupError
-------------

Right now I am not sure what kind of errors are going to come up, but for runtime errors that I anticipate I will raise a `SoupError` to try and make it more obvious what happened.

.. uml::

   SoupError -|> RuntimeError

<<name='SoupError', echo=False>>=
class SoupError(RuntimeError):
    """
    Raise if something is detected at run-time.
    """
@

The BroadcomRadioSoup
---------------------

This is a class to hold BeautifulSoup for the Broadcom Access point ``radio.asp`` page. I had hoped to do a single class for the Broadcom Web Interface but inspecting the pages reveals that the names have conflicts which would likely make it too confusing.

The Soup Queries
~~~~~~~~~~~~~~~~

There are different kinds of queries going on in the BroadcomRadioSoup and since I'm already having trouble remembering what is going on, I'll document some of them here.

Find
++++

The query::

    self.soup.find(attrs={'name':'wl_unit'})

Returns a `tag <http://www.crummy.com/software/BeautifulSoup/bs4/doc/#tag>`_ which is an HTML sub-tree that has the name attribute that passed in to the ``find`` call (see the :ref:`Wireless Interface <broadcom-parser-wireless-interface>` section above for a sample output). Because it is a tag, you can do further searches within it. Use the ``find`` method to narrow the HTML tree down to just the part you are interested in.

Tag Attributes
++++++++++++++

The query::

    self.soup.find(attrs={'name':'wl_country_code'}).option['value']

First uses find to narrow the tree down to the subtree::

    <select name="wl_country_code" onchange="wl_recalc();">
    <option selected value="US"></option>
    </select>


Within this sub-tree the tag named `option`  has an attribute  named `value`, so the ``.option['value']`` returns the right-hand-side of ``value="US"``. This is the syntax used to get text from tag-attributes (as opposed to text between tags).

Text
~~~~

This query::

    self.soup.find(attrs={'name':'wl_radio'}).find(attrs={'value':'0'}).text

First uses ``find` to narrow the HTML tree down to the 'wl_radio' subtree (BeautifulSoup tag)::

    <select name="wl_radio">
    <option selected value="0">Disabled</option>
    <option value="1">Enabled</option>
    </select>

Then it uses ``find`` again to get the ``option`` tag that has the ``value="0"`` attribute (this is the first item in the drop-down menu which seems to mostly mean the 2.4 GHz interface, but be aware that this is an index, not an actual assignment -- in another menu ``value="0"`` will also get you the first item in the menu, but that is not guaranteed to mean the 2.4 GHz interface, it is context specific)::

    <option selected value="0">Disabled</option>

Then uses ``.text`` to get the state of the interface. Use ``.text`` to get the text between tags.
    
<<name='imports', echo=False>>=
# python standard library
import re

# third-party
import bs4

# this package
from apcommand.baseclass import BaseClass
@
<<name="soup_constants", echo=False>>=
NAME = 'name'
VALUE = 'value'
GHZ_24 = '0'
GHZ_5 = '1'
VALUE_24 = {VALUE:GHZ_24}
VALUE_5 = {VALUE:GHZ_5}
WIRELESS_INTERFACE = 'wl_unit'
INTERFACE = 'wl_radio'
COUNTRY = 'wl_country_code'
CHANNEL = 'wl_channel'
BANDWIDTH = 'wl_nbw_cap'
SELECTED_EXPRESSION = r'selected\svalue=.*>(?P<{0}>.*)<'
BANDWIDTH_EXPRESSION = SELECTED_EXPRESSION.format(BANDWIDTH)
SIDEBAND = 'wl_nctrlsb'
SIDEBAND_EXPRESSION = SELECTED_EXPRESSION.format(SIDEBAND)
@
.. uml::

   BroadcomRadioSoup -|> BaseClass

User (client) API
+++++++++++++++++

This is the interface for those who want to use this to get text from an html input.
   
.. autosummary::
   :toctree: api

   BroadcomRadioSoup
   BroadcomRadioSoup.html
   BroadcomRadioSoup.mac_24_ghz
   BroadcomRadioSoup.mac_5_ghz
   BroadcomRadioSoup.country
   BroadcomRadioSoup.interface_24_state
   BroadcomRadioSoup.interface_5_state
   BroadcomRadioSoup.channel
   BroadcomRadioSoup.bandwidth
   BroadcomRadioSoup.sideband

Developer API
+++++++++++++

This is the interface for those who want to add to the Soup.

.. autosummary::
   :toctree: api

   BroadcomRadioSoup
   BroadcomRadioSoup.html
   BroadcomRadioSoup.soup
   BroadcomRadioSoup.wireless_interface
   BroadcomRadioSoup.get_24_ghz
   BroadcomRadioSoup.get_5_ghz
   
<<name='BroadcomRadioSoup', echo=False>>=
class BroadcomRadioSoup(BaseClass):
    """
    A holder of BeautifulSoup
    """
    def __init__(self, html=None):
        """
        Broadcom soup constructor

        :param:

         - `html`: a file-object or string to pass to BeautifulSoup
        """
        super(BroadcomRadioSoup, self).__init__()
        self._html = None
        self.html = html
        self._soup = None

        # the sub-trees and text
        self._wireless_interface = None
        self._mac_24_ghz = None
        self._mac_5_ghz = None
        self._country = None
        self._interface_24_state = None
        self._interface_5_state = None
        self._channel = None
        self._bandwidth = None
        self._sideband = None
        return

    @property
    def html(self):
        """
        The html for soup        
        """
        return self._html

    @html.setter
    def html(self, new_html):
        """
        sets the html, resets the soup
        """
        self._html = new_html
        self._soup = None
        return

    @property
    def soup(self):
        """
        A beautiful soup object created from self.html

        :return: BeautifulSoup with self.html loaded
        :raise: SoupError if something went wrong
        """
        if self._soup is None:
            try:
                self._soup = bs4.BeautifulSoup(self.html)
            except TypeError as error:
                self.logger.error(error)
                raise SoupError("unable to create soup from {0}".format(self.html))
        return self._soup

    @property
    def wireless_interface(self):
        """
        The `wl_unit` sub-tree
        """
        return self.soup.find(attrs={NAME:WIRELESS_INTERFACE})

    def get_24_ghz(self, tag):
        """
        Gets the first 24 ghz tag from a tag (subtree)

        :param:

         - `tag`: bs4.element.Tag with 2.4 GHz tag in it

        :return: tag with 2.4 GHz value
        """
        return tag.find(attrs=VALUE_24)

    def get_5_ghz(self, tag):
        """
        Gets the first 5 Ghz tag from a tag (subtree)

        :param:

         - `tag`: bs4.element.Tag with 5 GHz tag in it

        :return: bs4.element.Tag child of original tag 
        """
        return tag.find(attrs=VALUE_5)

    @property
    def mac_24_ghz(self):
        """
        The 2.4 GHz MAC address text from the wl_unit

        :return: (<MAC ADDRESS>)
        """
        return self.get_24_ghz(self.wireless_interface).text

    @property
    def mac_5_ghz(self):
        """
        The 5 GHz MAC address text from the wl_unit tag

        :return: (<5 GHz MAC Address>)
        """
        return self.get_5_ghz(self.wireless_interface).text

    @property
    def country(self):
        """
        Gets the current country setting

        :return: Country Code (e.g. 'US')
        """
        return self.soup.find(attrs={NAME:COUNTRY}).option[VALUE]

    @property
    def interface_24_state(self):
        """
        Get the state of the 2.4 Ghz radio (enabled or disabled)

        :return: 'Enabled' or 'Disabled'
        """
        return self.soup.find(attrs={NAME:INTERFACE}).find(attrs=VALUE_24).text

    @property
    def interface_5_state(self):
        """
        Get the state of the 5 Ghz radio (enabled or disabled)

        :return: 'Enabled' or 'Disabled'
        """
        return self.soup.find(attrs={NAME:INTERFACE}).find(attrs=VALUE_5).text

    @property
    def channel(self):
        """
        Gets the channel for the currently selected interface
        """
        return self.soup.find(attrs={NAME:CHANNEL}).option[VALUE]

    @property
    def bandwidth(self):
        """
        The bandwidth setting (for both bands)
        """
        for line in self.soup.find(attrs={NAME:BANDWIDTH}):
            match = re.search(BANDWIDTH_EXPRESSION, str(line))
            if match:
                return match.group(BANDWIDTH)

    @property
    def sideband(self):
        """
        Gets the sideband (only for 40GHz)

        :return: 'Upper', 'Lower', or None
        """
        for line in self.soup.find(attrs={NAME:SIDEBAND}):
            match = re.search(SIDEBAND_EXPRESSION, str(line))
            if match:
                return match.group(SIDEBAND).rstrip()
        
@

<<name='test_imports', echo=False>>=
# python standard library
import unittest
import random
choose = random.choice

# third-party
from mock import MagicMock, patch
@
<<name='TestBroadcomRadioSoup', echo=False>>=
class TestBroadcomRadioSoup(unittest.TestCase):
    def setUp(self):
        # if you put a file open outside of the class imports will crash
        # unless you happen to be running the code in this folder
        self.radio_html = open('radio_asp.html').read()
        self.soup = BroadcomRadioSoup(self.radio_html)
        self.soup_5 = BroadcomRadioSoup(open('radio_5_asp.html').read())
        return

    def test_constructor(self):
        """
        Does it the constructor set the right parameters
        """
        self.assertEqual(self.radio_html, self.soup.html)
        return

    def test_soup(self):
        """
        Does BeautfulSoup get passed the html attribute?
        """
        soup = MagicMock()
        with patch('bs4.BeautifulSoup', soup):
            self.soup.soup
        soup.assert_called_with(self.soup.html)

        # now get rid of the html
        self.soup.html = None
        
        # beautiful soup takes html at construction, changing html should reset soup
        self.assertIsNone(self.soup._soup)

        # if the html isn't set, how will you make soup?
        with self.assertRaises(SoupError):
            self.soup.soup
        return

    def test_interface(self):
        """
        Does it get the wireless interface?
        """
        # wl_unit is defined in the explanatory text
        self.assertEqual(wl_unit, str(self.soup.wireless_interface))
        return

    def test_get_band(self):
        """
        Does it get the band option from a tag?
        """
        band_24 = '<option selected value="0">(00:90:4C:09:11:03)</option>'
        band_5 = '<option value="1">(00:90:4C:13:11:03)</option>'

        tag = self.soup.wireless_interface
        outcome = self.soup.get_24_ghz(tag)
        self.assertEqual(str(outcome), band_24)

        self.assertEqual(str(self.soup.get_5_ghz(tag)), band_5)
        return

    def test_mac_address(self):
        """
        Does it get the 2.4 GHz and 5 GHz MAC Addresses?
        """
        band_24 = '(00:90:4C:09:11:03)'
        band_5 = '(00:90:4C:13:11:03)'
        self.assertEqual(self.soup.mac_24_ghz, band_24 )
        self.assertEqual(self.soup.mac_5_ghz, band_5)
        return

    def test_country_code(self):
        """
        Does it extract the current country?
        """
        self.assertEqual(self.soup.country, 'US')
        return

    def test_radio_state(self):
        """
        Does it correctly get the state of the radio?
        """
        self.assertEqual(self.soup.interface_24_state, 'Disabled')
        self.assertEqual(self.soup.interface_5_state, 'Enabled')
        return

    def test_channel(self):
        """
        Does it get the current channel?
        """
        # unlike other parts of the page this only lists the channel for the current interface
        self.assertEqual(self.soup.channel, '36')
        return

    def test_bandwidth(self):
        """
        Does it get the bandwidth?
        """
        # the Broadcom sets values for both bands
        # you need to pair this outcome with the current interface to get
        # current bandwidth
        self.assertEqual(self.soup.bandwidth, "20MHz in 2.4G Band and 40MHz in 5G Band")
        return

    def test_sideband(self):
        """
        Does it get the right sideband (5GHz only)?
        """
        self.assertIsNone(self.soup.sideband)
        self.assertEqual(self.soup_5.sideband, 'Lower')
@
<%
for case in (TestBroadcomRadioSoup,):
    suite = unittest.TestLoader().loadTestsFromTestCase(case)    
    unittest.TextTestRunner(verbosity=2).run(suite)
%>
